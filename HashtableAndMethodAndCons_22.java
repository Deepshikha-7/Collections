/*Hashtable:-
 *1) Hashtable is the direct implemented class of Map interface.
 *2) Syntax:-
 *	 Package java.util;
 *	 class Hashtable extends Dictionary implements Map
 *	 {
 *		//constructors
 *		//methods
 *	 }
 *3) It is a legacy class and introduced in JDK 1.0 version.
 *4) Hashtable underline data structure is  Hashtable
 *
 *Properties of Hashtable:-
 *1) Hashtable contains the data in key-value pair is known as entry.
 *2) In Hashtable, keys should always be unique but values can be duplicate.
 *3) Hashtable can store heterogeneous elements or different type of elements at key position
 *4) We cannot store null value in the Hashtable.
 *5) Hashtable does not follow the insertion and sorting order.
 *6) Hashtable are synchronized data-structure.
 *
 *Working of Hashtable:-
 *->Hashtable ht = new Hashtable(); :-
 * when we create the object of Hashtable so hashtable is created in the background 
 * which is also called bucket and it's default initial capacity will be 11.  
 *
 *->ht.put(106, "Deepak"); :-
 *	When we store data in the Hashtable so in the key some hash code will generated by JVM
 *	(In java, hash code is a unique integer value that generated for every object)
 *	eg:- hash code % 11 = reminder -> that how hash code is generated
 *	suppose we have hash code 106%11=7 we got 7 so at the 7th index position entry 106=Deepak
 *  will get store in the bucket
 *  Now we are putting ht.put(102,"Kamal"); suppose it's hash code value 102%11=3  so at the
 *  index number 3 102=Kamal will get store in the bucket
 *  ht.put(108, "Ravi) it's hash code value 108%11=9, at the 9 index number 108=Ravi will
 *  get store
 *  ht.put(117,"Rahul") in this now hash code value 117%11=7 so we code 7 index position
 *  but in the 7th position we have already a value stored in the bucket this situation is
 *  called hash-collition it is the situation when multiple data shares the same indices value
 *  so in this situation LinkedList will be used in the background that will create a node
 *  and in that node our element will get store that is 117=Rahul and 7 index position will
 *  point that node how that both element will get store in 7th position.
 *->How Hashtable get retrieved:- From top to bottom and from right to left so our output
 *	we be {108=Ravi, 117=Rahul, 106=Deepak, 102=Kamal}
 *
 *
 *Hashtable class constructors:-
 *1) public Hashtable() {};
 *2) public Hashtable(int initialCapacity) {};
 *3) public Hashtable(int initialCapacity, float loadFactor) {};
 *4) public Hashtable(Map t) {};
 *
 *Hashtable class methods:-
 *1) put();
 *2) get();
 *3) hashCode();
 *4) containsKey();
 *5) containsValue();
 *6) size();
 *7) remove();
 *8) clear();
 *	--------etc.
 *
 **/

package com.java.collections;

import java.util.Hashtable;

public class HashtableAndMethodAndCons_22 {}	//This class is not for use only for class file naming purpose.

	
//Use of Hashtable
class HashtableDemo {	
	public static void main(String[] args) {
		
		//default constructor
		Hashtable ht = new Hashtable();
		ht.put(102, "Deepak");
		ht.put(106, "Kamal");
		ht.put(108, "Ravi");
		ht.put(117, "Rahul");
//		ht.put(117, "Hello")	//duplicate key is not allowed but you can use duplicate value
		System.out.println(ht);
		
		//parameterized constructor(Provide Map object reference)
		Hashtable ht2 = new Hashtable(ht);
		ht2.put("Hello", 123);	//You can use heterogeneous data types
		ht2.put("Sonu", "Sonu");
		ht2.put("Monu", 1);
		ht2.put("Subham", 2);
		System.out.println(ht2);
		
		//get()
		System.out.println(ht2.get("Hello"));
		
		//hashCode()
		System.out.println(ht2.hashCode()); //get hash code of the Hashtable
		
		//containsKey()
		System.out.println(ht2.containsKey(117));
		System.out.println(ht2.containsKey(118));
		
		//containsValue()
		System.out.println(ht2.containsValue("Sonu"));
		System.out.println(ht2.containsValue("Soni"));
		
		//size() 
		System.out.println(ht2.size());
		
		//remove()
		ht2.remove("Sonu");
		System.out.println(ht2);
		
		//clear()
		ht2.clear();
		System.out.println(ht2);
	}
}
